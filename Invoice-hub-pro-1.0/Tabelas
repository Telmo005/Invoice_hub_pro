-- =============================================
-- Configuração Inicial
-- =============================================
-- Habilita extensões necessárias
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- =============================================
-- Tabela de Emissores (Empresas/Usuários que emitem faturas)
-- =============================================
CREATE TABLE emissores (
    -- Identificação
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Dados da empresa (conforme interface)
    nome_empresa TEXT NOT NULL,
    documento TEXT NOT NULL,
    pais TEXT NOT NULL,
    cidade TEXT NOT NULL,
    bairro TEXT NOT NULL,
    
    -- Contato
    pessoa_contato TEXT,
    email TEXT NOT NULL,
    telefone TEXT NOT NULL,
    
    -- Metadados
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Restrições
    UNIQUE (user_id, documento),
    CONSTRAINT documento_valido CHECK (documento ~ '^[0-9]{11,14}$')
);

COMMENT ON TABLE emissores IS 'Armazena informações dos emissores de faturas, vinculados a usuários do sistema';
COMMENT ON COLUMN emissores.user_id IS 'Vinculação com a tabela de usuários do Supabase Auth';
COMMENT ON COLUMN emissores.documento IS 'CPF ou CNPJ do emissor (somente números)';

-- =============================================
-- Tabela de Destinatários (Clientes)
-- =============================================
CREATE TABLE destinatarios (
    -- Identificação
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Dados do destinatário (conforme interface)
    nome_completo TEXT NOT NULL,
    documento TEXT,
    pais TEXT,
    cidade TEXT,
    bairro TEXT,
    
    -- Contato
    email TEXT NOT NULL,
    telefone TEXT NOT NULL,
    
    -- Metadados
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE destinatarios IS 'Armazena informações dos clientes/destinatários das faturas';
COMMENT ON COLUMN destinatarios.documento IS 'CPF ou CNPJ do destinatário (opcional, somente números)';

-- =============================================
-- Tabela de Faturas (Cabeçalho)
-- =============================================
CREATE TABLE faturas (
    -- Identificação
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    
    -- Relacionamentos
    emitente_id UUID NOT NULL REFERENCES emissores(id) ON DELETE RESTRICT,
    destinatario_id UUID NOT NULL REFERENCES destinatarios(id) ON DELETE RESTRICT,
    
    -- Dados principais (conforme interface FormData)
    numero TEXT NOT NULL,
    data_fatura DATE NOT NULL DEFAULT CURRENT_DATE,
    data_vencimento DATE NOT NULL,
    ordem_compra TEXT,
    termos TEXT NOT NULL,
    moeda TEXT NOT NULL DEFAULT 'BRL',
    
    -- Arquivos
    logo_url TEXT,
    assinatura_base64 TEXT,
    
    -- Metadados
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Restrições
    UNIQUE (user_id, numero),
    CONSTRAINT moeda_valida CHECK (moeda ~ '^[A-Z]{3}$')
);

COMMENT ON TABLE faturas IS 'Armazena o cabeçalho das faturas com dados do formulário';
COMMENT ON COLUMN faturas.moeda IS 'Código de 3 letras da moeda (ex: BRL, USD)';

-- =============================================
-- Tabela de Itens da Fatura
-- =============================================
CREATE TABLE itens_fatura (
    -- Identificação
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    fatura_id UUID NOT NULL REFERENCES faturas(id) ON DELETE CASCADE,
    
    -- Dados do item (conforme interface Item)
    id_original INTEGER NOT NULL,  -- Mantém o ID original do frontend
    quantidade NUMERIC(10, 3) NOT NULL,
    descricao TEXT NOT NULL,
    preco_unitario NUMERIC(12, 2) NOT NULL,
    
    -- Campo calculado
    total_item NUMERIC(12, 2) GENERATED ALWAYS AS (quantidade * preco_unitario) STORED,
    
    -- Metadados
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Restrições
    CONSTRAINT quantidade_positiva CHECK (quantidade > 0),
    CONSTRAINT preco_positivo CHECK (preco_unitario >= 0)
);

COMMENT ON TABLE itens_fatura IS 'Armazena os itens individuais de cada fatura';
COMMENT ON COLUMN itens_fatura.id_original IS 'ID original do frontend para sincronização';

-- =============================================
-- Tabela de Taxas por Item
-- =============================================
CREATE TABLE taxas_itens (
    -- Identificação
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    item_id UUID NOT NULL REFERENCES itens_fatura(id) ON DELETE CASCADE,
    
    -- Dados da taxa (conforme interface TaxaItem)
    nome TEXT NOT NULL,
    valor NUMERIC(12, 2) NOT NULL,
    tipo TEXT NOT NULL CHECK (tipo IN ('percent', 'fixed')),
    categoria TEXT NOT NULL,
    
    -- Metadados
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Restrições
    CONSTRAINT valor_positivo CHECK (valor >= 0)
);

COMMENT ON TABLE taxas_itens IS 'Armazena as taxas aplicadas a cada item da fatura';

-- =============================================
-- Tabela de Totais da Fatura
-- =============================================
CREATE TABLE totais_fatura (
    -- Identificação
    fatura_id UUID PRIMARY KEY REFERENCES faturas(id) ON DELETE CASCADE,
    
    -- Valores calculados (conforme interface Totais)
    subtotal NUMERIC(12, 2) NOT NULL,
    total_taxas NUMERIC(12, 2) NOT NULL,
    total_final NUMERIC(12, 2) NOT NULL,
    
    -- Metadados
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE totais_fatura IS 'Armazena os totais calculados da fatura';

-- =============================================
-- Tabela de Taxas Detalhadas (Agrupadas)
-- =============================================
CREATE TABLE taxas_detalhadas (
    -- Identificação
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    fatura_id UUID NOT NULL REFERENCES faturas(id) ON DELETE CASCADE,
    
    -- Dados da taxa (conforme interface TaxaDetalhada)
    nome TEXT NOT NULL,
    valor NUMERIC(12, 2) NOT NULL,
    
    -- Metadados
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE taxas_detalhadas IS 'Armazena o detalhamento das taxas aplicadas na fatura';

-- =============================================
-- Índices para Melhor Performance
-- =============================================
CREATE INDEX idx_emissores_usuario ON emissores(user_id);
CREATE INDEX idx_destinatarios_usuario ON destinatarios(user_id);
CREATE INDEX idx_faturas_usuario ON faturas(user_id);
CREATE INDEX idx_faturas_emitente ON faturas(emitente_id);
CREATE INDEX idx_faturas_destinatario ON faturas(destinatario_id);
CREATE INDEX idx_itens_fatura ON itens_fatura(fatura_id);
CREATE INDEX idx_taxas_itens ON taxas_itens(item_id);
CREATE INDEX idx_taxas_detalhadas ON taxas_detalhadas(fatura_id);

-- =============================================
-- Funções e Triggers Úteis
-- =============================================
-- Função para atualizar timestamps
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers para atualização automática
CREATE TRIGGER trigger_update_emissores
BEFORE UPDATE ON emissores
FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER trigger_update_destinatarios
BEFORE UPDATE ON destinatarios
FOR EACH ROW EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER trigger_update_faturas
BEFORE UPDATE ON faturas
FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- Função para sincronizar totais automaticamente
CREATE OR REPLACE FUNCTION sync_totais_fatura()
RETURNS TRIGGER AS $$
BEGIN
    -- Atualiza totais da fatura
    INSERT INTO totais_fatura (
        fatura_id,
        subtotal,
        total_taxas,
        total_final
    )
    SELECT 
        COALESCE(NEW.fatura_id, OLD.fatura_id),
        COALESCE(SUM(i.total_item), 0),
        COALESCE(SUM(t.valor), 0),
        COALESCE(SUM(i.total_item), 0) + COALESCE(SUM(t.valor), 0)
    FROM itens_fatura i
    LEFT JOIN taxas_itens t ON t.item_id = i.id
    WHERE i.fatura_id = COALESCE(NEW.fatura_id, OLD.fatura_id)
    ON CONFLICT (fatura_id) DO UPDATE SET
        subtotal = EXCLUDED.subtotal,
        total_taxas = EXCLUDED.total_taxas,
        total_final = EXCLUDED.total_final;
    
    -- Atualiza taxas detalhadas
    DELETE FROM taxas_detalhadas 
    WHERE fatura_id = COALESCE(NEW.fatura_id, OLD.fatura_id);
    
    INSERT INTO taxas_detalhadas (fatura_id, nome, valor)
    SELECT 
        COALESCE(NEW.fatura_id, OLD.fatura_id),
        t.categoria,
        SUM(t.valor)
    FROM taxas_itens t
    JOIN itens_fatura i ON t.item_id = i.id
    WHERE i.fatura_id = COALESCE(NEW.fatura_id, OLD.fatura_id)
    GROUP BY t.categoria;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers para sincronização automática
CREATE TRIGGER trigger_sync_totais_itens
AFTER INSERT OR UPDATE OR DELETE ON itens_fatura
FOR EACH ROW EXECUTE FUNCTION sync_totais_fatura();

CREATE TRIGGER trigger_sync_totais_taxas
AFTER INSERT OR UPDATE OR DELETE ON taxas_itens
FOR EACH ROW EXECUTE FUNCTION sync_totais_fatura();

-- =============================================
-- Políticas de Segurança (RLS)
-- =============================================
-- Habilita RLS em todas as tabelas
ALTER TABLE emissores ENABLE ROW LEVEL SECURITY;
ALTER TABLE destinatarios ENABLE ROW LEVEL SECURITY;
ALTER TABLE faturas ENABLE ROW LEVEL SECURITY;
ALTER TABLE itens_fatura ENABLE ROW LEVEL SECURITY;
ALTER TABLE taxas_itens ENABLE ROW LEVEL SECURITY;
ALTER TABLE totais_fatura ENABLE ROW LEVEL SECURITY;
ALTER TABLE taxas_detalhadas ENABLE ROW LEVEL SECURITY;

-- Políticas para Emissores
CREATE POLICY "Usuários gerenciam seus próprios emissores" 
ON emissores FOR ALL 
USING (user_id = auth.uid());

-- Políticas para Destinatários
CREATE POLICY "Usuários gerenciam seus próprios destinatários" 
ON destinatarios FOR ALL 
USING (user_id = auth.uid());

-- Políticas para Faturas
CREATE POLICY "Usuários gerenciam suas próprias faturas" 
ON faturas FOR ALL 
USING (user_id = auth.uid());

-- Políticas para Itens
CREATE POLICY "Acesso aos itens via fatura do usuário"
ON itens_fatura FOR ALL 
USING (
    EXISTS (
        SELECT 1 FROM faturas 
        WHERE faturas.id = itens_fatura.fatura_id 
        AND faturas.user_id = auth.uid()
    )
);

-- Políticas para Taxas (padrão similar para outras tabelas relacionadas)
CREATE POLICY "Acesso às taxas via itens do usuário"
ON taxas_itens FOR ALL 
USING (
    EXISTS (
        SELECT 1 FROM itens_fatura i
        JOIN faturas f ON i.fatura_id = f.id
        WHERE i.id = taxas_itens.item_id
        AND f.user_id = auth.uid()
    )
);

-- =============================================
-- Função para Criar Fatura Completa (JSON)
-- =============================================
CREATE OR REPLACE FUNCTION criar_fatura_completa(
    p_emitente JSONB,
    p_destinatario JSONB,
    p_fatura JSONB,
    p_itens JSONB[]
) RETURNS UUID AS $$
DECLARE
    v_emitente_id UUID;
    v_destinatario_id UUID;
    v_fatura_id UUID;
    v_item JSONB;
BEGIN
    -- 1. Inserir/Atualizar Emitente
    INSERT INTO emissores (
        user_id, nome_empresa, documento, pais, cidade, bairro,
        pessoa_contato, email, telefone
    ) VALUES (
        auth.uid(),
        p_emitente->>'nomeEmpresa',
        p_emitente->>'documento',
        p_emitente->>'pais',
        p_emitente->>'cidade',
        p_emitente->>'bairro',
        p_emitente->>'pessoaContato',
        p_emitente->>'email',
        p_emitente->>'telefone'
    )
    ON CONFLICT (user_id, documento) DO UPDATE SET
        nome_empresa = EXCLUDED.nome_empresa,
        email = EXCLUDED.email,
        telefone = EXCLUDED.telefone,
        updated_at = NOW()
    RETURNING id INTO v_emitente_id;

    -- 2. Inserir/Atualizar Destinatário
    INSERT INTO destinatarios (
        user_id, nome_completo, documento, pais, cidade, bairro,
        email, telefone
    ) VALUES (
        auth.uid(),
        p_destinatario->>'nomeCompleto',
        p_destinatario->>'documento',
        p_destinatario->>'pais',
        p_destinatario->>'cidade',
        p_destinatario->>'bairro',
        p_destinatario->>'email',
        p_destinatario->>'telefone'
    )
    RETURNING id INTO v_destinatario_id;

    -- 3. Inserir Fatura
    INSERT INTO faturas (
        user_id, emitente_id, destinatario_id,
        numero, data_fatura, data_vencimento,
        ordem_compra, termos, moeda,
        logo_url, assinatura_base64
    ) VALUES (
        auth.uid(), v_emitente_id, v_destinatario_id,
        p_fatura->>'faturaNumero',
        (p_fatura->>'dataFatura')::DATE,
        (p_fatura->>'dataVencimento')::DATE,
        p_fatura->>'ordemCompra',
        p_fatura->>'termos',
        p_fatura->>'moeda',
        p_fatura->>'logo',
        p_fatura->>'assinatura'
    )
    RETURNING id INTO v_fatura_id;

    -- 4. Inserir Itens e Taxas
    FOREACH v_item IN ARRAY p_itens LOOP
        DECLARE
            v_item_id UUID;
        BEGIN
            -- Inserir Item
            INSERT INTO itens_fatura (
                fatura_id, id_original,
                quantidade, descricao, preco_unitario
            ) VALUES (
                v_fatura_id,
                (v_item->>'id')::INTEGER,
                (v_item->>'quantidade')::NUMERIC,
                v_item->>'descricao',
                (v_item->>'precoUnitario')::NUMERIC
            )
            RETURNING id INTO v_item_id;

            -- Inserir Taxas do Item
            IF v_item->'taxas' IS NOT NULL THEN
                INSERT INTO taxas_itens (
                    item_id, nome, valor, tipo, categoria
                )
                SELECT
                    v_item_id,
                    taxa->>'nome',
                    (taxa->>'valor')::NUMERIC,
                    taxa->>'tipo',
                    taxa->>'categoria'
                FROM jsonb_array_elements(v_item->'taxas') AS taxa;
            END IF;
        END;
    END LOOP;

    RETURN v_fatura_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION criar_fatura_completa IS 'Função para criar uma fatura completa com todos os relacionamentos em uma única transação';

ALTER TABLE emissores 
DROP CONSTRAINT IF EXISTS documento_valido;

-- Nova constraint que aceita qualquer texto (mas não vazio)
ALTER TABLE emissores
ADD CONSTRAINT documento_valido 
CHECK (documento ~ '^.+$');  -- Aceita qualquer string com pelo menos 1 caractere
