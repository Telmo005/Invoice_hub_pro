-- 1. ATUALIZAÇÃO DA TABELA DE PAGAMENTOS

-- Renomear coluna payment_id para external_id
ALTER TABLE payments RENAME COLUMN payment_id TO external_id;

-- Alterar tipo da coluna id para UUID
ALTER TABLE payments 
ALTER COLUMN id DROP DEFAULT,
ALTER COLUMN id TYPE UUID USING gen_random_uuid();

ALTER TABLE payments
ALTER COLUMN id SET DEFAULT gen_random_uuid();

-- Alterar tipo das colunas method e status
ALTER TABLE payments
ALTER COLUMN method TYPE VARCHAR(20),
ALTER COLUMN status TYPE VARCHAR(20);

-- Adicionar constraints para method e status
ALTER TABLE payments
ADD CONSTRAINT payments_method_check CHECK (method IN ('m-pesa', 'e-mola', 'transfer', 'cash')),
ADD CONSTRAINT payments_status_check CHECK (status IN ('pending', 'completed', 'failed', 'refunded'));

-- Adicionar novas colunas à tabela payments
ALTER TABLE payments
ADD COLUMN metadata JSONB,
ADD COLUMN user_id UUID REFERENCES auth.users NOT NULL DEFAULT '00000000-0000-0000-0000-000000000000',
ADD COLUMN updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
ADD COLUMN receipt_url TEXT;

-- 2. ATUALIZAÇÃO DA TABELA DE FATURAS

ALTER TABLE invoices 
ADD COLUMN payment_due_date DATE,
ADD COLUMN notes TEXT;

-- 3. ATUALIZAÇÃO DA TABELA DE RELACIONAMENTO DE PARTES

ALTER TABLE invoice_parties
ADD COLUMN issuer_address TEXT,
ADD COLUMN recipient_address TEXT;

-- 4. CRIAÇÃO DE NOVAS TABELAS

-- Tabela de histórico de status
CREATE TABLE invoice_status_history (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  invoice_id UUID REFERENCES invoices(id) NOT NULL,
  status TEXT NOT NULL,
  changed_by UUID REFERENCES auth.users,
  notes TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Tabela de anexos de fatura
CREATE TABLE invoice_attachments (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  invoice_id UUID REFERENCES invoices(id) NOT NULL,
  file_url TEXT NOT NULL,
  file_name TEXT NOT NULL,
  file_type TEXT NOT NULL,
  uploaded_by UUID REFERENCES auth.users NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 5. CRIAÇÃO DE ÍNDICES ADICIONAIS

CREATE INDEX idx_payments_invoice_id ON payments(invoice_id);
CREATE INDEX idx_payments_user_id ON payments(user_id);
CREATE INDEX idx_payments_status ON payments(status);
CREATE INDEX idx_invoice_status_history_invoice_id ON invoice_status_history(invoice_id);
CREATE INDEX idx_invoice_attachments_invoice_id ON invoice_attachments(invoice_id);

-- 6. FUNÇÕES E TRIGGERS

-- Função para atualizar timestamp
CREATE OR REPLACE FUNCTION update_modified_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para atualizar invoices
CREATE TRIGGER update_invoices_modtime
BEFORE UPDATE ON invoices
FOR EACH ROW EXECUTE FUNCTION update_modified_column();

-- Trigger para atualizar payments
CREATE TRIGGER update_payments_modtime
BEFORE UPDATE ON payments
FOR EACH ROW EXECUTE FUNCTION update_modified_column();

-- Função para validar datas da fatura
CREATE OR REPLACE FUNCTION validate_invoice_dates()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.due_date < NEW.issue_date THEN
    RAISE EXCEPTION 'Due date cannot be before issue date';
  END IF;
  
  IF NEW.payment_due_date IS NOT NULL AND NEW.payment_due_date < NEW.issue_date THEN
    RAISE EXCEPTION 'Payment due date cannot be before issue date';
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para validar datas
CREATE TRIGGER check_invoice_dates
BEFORE INSERT OR UPDATE ON invoices
FOR EACH ROW EXECUTE FUNCTION validate_invoice_dates();

-- Função para validar faturas pagas
CREATE OR REPLACE FUNCTION validate_paid_invoice()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.status = 'paid' AND NOT EXISTS (
    SELECT 1 FROM payments 
    WHERE invoice_id = NEW.id AND status = 'completed'
  ) THEN
    RAISE EXCEPTION 'Invoice cannot be marked as paid without a completed payment';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para validar faturas pagas
CREATE TRIGGER trg_validate_paid_invoice
BEFORE INSERT OR UPDATE OF status ON invoices
FOR EACH ROW EXECUTE FUNCTION validate_paid_invoice();

-- 7. VIEWS PARA RELATÓRIOS

-- View para faturas com pagamentos
CREATE OR REPLACE VIEW invoice_with_payments AS
SELECT 
  i.*,
  p.id as payment_id,
  p.method as payment_method,
  p.status as payment_status,
  p.amount as payment_amount,
  p.created_at as payment_date,
  p.receipt_url
FROM invoices i
LEFT JOIN LATERAL (
  SELECT * FROM payments 
  WHERE invoice_id = i.id 
  ORDER BY created_at DESC 
  LIMIT 1
) p ON true;

-- View para relatório de taxas
CREATE OR REPLACE VIEW tax_report AS
SELECT 
  i.id as invoice_id,
  i.invoice_number,
  i.issue_date,
  ts.tax_name,
  ts.tax_amount,
  (ts.tax_amount / i.total_amount * 100) as tax_percentage
FROM invoices i
JOIN invoice_tax_summary ts ON ts.invoice_id = i.id;

-- View para histórico completo da fatura
CREATE OR REPLACE VIEW invoice_full_history AS
SELECT 
  i.id,
  i.invoice_number,
  i.status as current_status,
  h.status as history_status,
  h.created_at as status_change_date,
  u.email as changed_by_email,
  h.notes as status_notes
FROM invoices i
JOIN invoice_status_history h ON h.invoice_id = i.id
LEFT JOIN auth.users u ON h.changed_by = u.id
ORDER BY h.created_at DESC;

-- 8. STORED PROCEDURES

-- Procedure para atualizar status da fatura
CREATE OR REPLACE PROCEDURE update_invoice_status(
  invoice_id UUID,
  new_status TEXT,
  user_id UUID,
  notes TEXT DEFAULT NULL
)
LANGUAGE plpgsql
AS $$
BEGIN
  -- Atualiza o status principal
  UPDATE invoices 
  SET status = new_status, updated_at = NOW()
  WHERE id = invoice_id;
  
  -- Registra no histórico
  INSERT INTO invoice_status_history (invoice_id, status, changed_by, notes)
  VALUES (invoice_id, new_status, user_id, notes);
END;
$$;

-- Procedure para processar pagamento
CREATE OR REPLACE PROCEDURE process_payment(
  p_external_id TEXT,
  p_method TEXT,
  p_phone_number TEXT,
  p_amount NUMERIC,
  p_status TEXT,
  p_invoice_id UUID,
  p_user_id UUID,
  p_metadata JSONB DEFAULT NULL,
  p_receipt_url TEXT DEFAULT NULL
)
LANGUAGE plpgsql
AS $$
BEGIN
  -- Insere o pagamento
  INSERT INTO payments (
    external_id, method, phone_number, amount, status,
    invoice_id, user_id, metadata, receipt_url, invoice_data
  )
  SELECT 
    p_external_id, p_method, p_phone_number, p_amount, p_status,
    p_invoice_id, p_user_id, p_metadata, p_receipt_url,
    to_jsonb(i.*) - 'id' - 'created_at' - 'updated_at'
  FROM invoices i
  WHERE i.id = p_invoice_id;
  
  -- Se o pagamento foi completado, atualiza o status da fatura
  IF p_status = 'completed' THEN
    CALL update_invoice_status(p_invoice_id, 'paid', p_user_id, 'Pagamento processado via ' || p_method);
  END IF;
END;
$$;

-- 9. MIGRAÇÃO DE DADOS EXISTENTES (OPCIONAL)

-- Atualizar user_id nos pagamentos existentes
DO $$
BEGIN
  -- Verifica se a coluna user_id existe e está vazia
  IF EXISTS (SELECT 1 FROM information_schema.columns 
             WHERE table_name = 'payments' AND column_name = 'user_id') THEN
    UPDATE payments p
    SET user_id = i.user_id
    FROM invoices i
    WHERE p.invoice_id = i.id AND p.user_id = '00000000-0000-0000-0000-000000000000';
    
    RAISE NOTICE 'Updated user_id for % payments', (SELECT COUNT(*) FROM payments WHERE user_id != '00000000-0000-0000-0000-000000000000');
  END IF;
END $$;

-- 10. COMENTÁRIOS PARA DOCUMENTAÇÃO

COMMENT ON TABLE invoices IS 'Armazena as faturas principais do sistema';
COMMENT ON COLUMN invoices.payment_due_date IS 'Data limite para pagamento da fatura';
COMMENT ON COLUMN invoices.notes IS 'Observações adicionais sobre a fatura';

COMMENT ON TABLE payments IS 'Registros de pagamentos associados a faturas';
COMMENT ON COLUMN payments.external_id IS 'ID da transação no gateway de pagamento externo';
COMMENT ON COLUMN payments.metadata IS 'Dados adicionais do pagamento no formato JSON';

COMMENT ON TABLE invoice_status_history IS 'Histórico completo de alterações de status das faturas';
COMMENT ON TABLE invoice_attachments IS 'Arquivos anexados às faturas (PDFs, imagens, etc.)';
